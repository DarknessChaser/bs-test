<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>grid布局dome</title>
  <script src="../vue-test/js/vue.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    hr {
      margin: 5px 0;
    }

    #app {
      width: 95vw;
      border: 5px solid gray;
      margin: 0 auto;
      padding: 5px;
      overflow-x: auto;
    }

    .grid-body {
      display: grid;
      position: relative;
    }

    .grid-item {
      text-align: center;
      font-size: 24px;
      touch-action: none;
    }

    .charts-body {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    .chart-item {
      position: absolute;
    }

    .chart-template {
      float: left;
      margin: 5px;
      background-color: #2e6da4;
      text-align: center;
      font-size: 24px;
    }
  </style>
</head>
<body>
<div id="app">
  <label>
    div尺寸：
    <input type="text" v-model.number.lazy="baseLength">
  </label>
  <label>
    div间距：
    <input type="text" v-model.number.lazy="baseMargin">
  </label>
  <label>
    行：
    <input type="text" v-model.number.lazy="row">
  </label>
  <label>
    列：
    <input type="text" v-model.number.lazy="col">
  </label>
  <hr>
  <label>
    最小行：
    <input type="text" v-model.number.lazy="minRow">
  </label>
  <label>
    最小列：
    <input type="text" v-model.number.lazy="minCol">
  </label>
  <label>
    最大行：
    <input type="text" v-model.number.lazy="maxRow">
  </label>
  <label>
    最大列：
    <input type="text" v-model.number.lazy="maxCol">
  </label>
  <hr>
  <label>
    是否显示charts-body
    <input type="checkbox" v-model="show">
  </label>
  <label>
    新chart插入的index：
    <input type="text" v-model.number.lazy="newIndex">
  </label>
  <label>
    新chart的尺寸：
    <input type="text" v-model.number.lazy="newWidth">
    *
    <input type="text" v-model.number.lazy="newHeight">
    <button @click="addChart">添加新chart</button>
  </label>
  最新chart参数：{{charts[charts.length-1]}}
  <hr>
  <div
      class="grid-body"
      :style="{
            gridTemplateRows: `repeat(${row}, ${baseLength}px)`,
            gridTemplateColumns: `repeat(${col}, ${baseLength}px)`,
            gridRowGap: `${baseMargin}px`,
            gridColumnGap: `${baseMargin}px`,
            width: `${col*baseLength+(col-1)*baseMargin}px`,
            height: `${row*baseLength+(row-1)*baseMargin}px`,
        }"
  >
    <div
        v-for="index in row*col"
        :key="index"
        class="grid-item"
        :style="{
                backgroundColor:'rgba(232,232,232,0.7)',
            }"
    >
      <span>b{{index}}</span>
    </div>
    <div
        v-show="show"
        class="charts-body"
        @dragover.prevent="handleDragover"
    >
      <div
          v-for="(chart,index) in charts"
          :key="index"
          class="grid-item chart-item"
          draggable="true"
          @dragstart="handleDragstart"
          @dragend="handleDragend(index)"
          :style="{
                    backgroundColor:randomRGBColor(),
                    width: `${chart.width*baseLength+(chart.width-1)*baseMargin}px`,
                    height: `${chart.height*baseLength+(chart.height-1)*baseMargin}px`,
                    transform: `translate(${(chart.startCol-1)*(baseLength+baseMargin)}px, ${(chart.startRow-1)*(baseLength+baseMargin)}px)`,
               }"
      >
        <span>{{index}}</span>
      </div>
    </div>
  </div>
  <hr>
  <div
      class="chart-template"
      v-for="(template,index) in chartTemplates"
      draggable="true"
      @dragstart="handleTemplateDragstart"
      @dragend="handleTemplateDragend($event,index)"
      :style="{
          width: `${template.width*baseLength}px`,
          height: `${template.height*baseLength}px`,
      }"
  >
    {{ `${template.width}*${template.height}` }}
  </div>
</div>
</body>
<script>
  let DragstartPageX, DragstartPageY, DragoverPageX, DragoverPageY;
  const vm = new Vue({
    el: '#app',
    data: {
      baseLength: 120,
      baseMargin: 10,
      row: 4,
      col: 8,
      minRow: 4,
      minCol: 8,
      maxRow: 5,
      maxCol: 15,
      show: true,
      charts: [],
      chartTemplates: [
        {
          height: 2,
          width: 2,
        },
        {
          height: 1,
          width: 1,
        },
        {
          height: 3,
          width: 4,
        },
      ],
      newIndex: 5,
      newHeight: 2,
      newWidth: 2,
    },
    computed: {
      safeItems() {
        const safeSets = new Set();
        for (let i = 1; i <= this.row * this.col; i++) {
          safeSets.add(i);
        }
        this.charts.forEach((chart) => {
          this.getBlocks(chart).forEach((block) => {
            safeSets.delete(block);
          });
        })
        return [...safeSets].sort((a, b) => a - b);
      },
    },
    watch: {
      charts() {
        this.resetLayoutSize();
      },
    },
    created() {
    },
    mounted() {
      document.addEventListener("dragover", this.handleFireFoxDragover);
    },
    beforeDestroy() {
      document.removeEventListener("dragover", this.handleFireFoxDragover);
    },
    methods: {
      randomRGBColor() {	//随机生成rgb颜色
        const r = Math.floor(Math.random() * 255);
        const g = Math.floor(Math.random() * 255);
        const b = Math.floor(Math.random() * 255);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      },
      addChart() {
        const startRow = parseInt((this.newIndex - 1) / this.col) + 1;
        const startCol = (this.newIndex - 1) % this.col + 1;
        const newChart = {
          startRow,
          startCol,
          height: this.newHeight,
          width: this.newWidth,
        };
        if (this.checkBlocksIsSafe(newChart)) {
          this.charts.push(this.getSafeMinRow(newChart));
          this.resetCharts();
        }
      },
      getBlocks(chart) {
        const unsafeBlocks = [];
        const {startRow, startCol, height, width} = chart;
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            unsafeBlocks.push((startRow - 1) * this.col + startCol + i * this.col + j);
          }
        }
        return unsafeBlocks.sort((a, b) => a - b);
      },
      checkBlocksIsSafe(chart, oldChart = {}, noMove = false) {
        const {startRow, startCol, height, width} = chart;
        if (startRow < 1 || startCol < 1) {
          alert('格子超出了画布！');
          return false;
        }
        if (startRow + height - 1 > this.maxRow || startCol + width - 1 > this.maxCol) {
          alert('超出画布最大尺寸');
          return false;
        }
        this.setLayoutSize(chart);
        const blocks = this.getBlocks(chart);
        const oldBlocks = this.getBlocks(oldChart);
        if (blocks.every((block) => [...this.safeItems, ...oldBlocks].includes(block))) {
          return true;
        }
        // alert('格子叠起来了！');
        if (!noMove) {
          const unsafeItems = this.getUnsafeItems(oldChart);
          unsafeItems.forEach((unsafeBlocks, index) => {
            if (unsafeBlocks.some((unsafeBlock) => blocks.includes(unsafeBlock))) {
              const targetChart = this.charts[index];
              const newChart = {
                startCol: targetChart.startCol,
                startRow: targetChart.startRow + 1,
                height: targetChart.height,
                width: targetChart.width,
              }
              while (this.getBlocks(newChart).some((block) => blocks.includes(block))) {
                newChart.startRow += 1;
              }
              if (this.checkBlocksIsSafe(newChart, targetChart)) {
                this.$set(this.charts, index, newChart);
              }
            }
          });
          return true;
        } else {
          return false;
        }
      },
      getUnsafeItems(targetChart) {
        const unsafeSets = new Set();
        this.charts.forEach((chart) => {
          if (targetChart !== chart) {
            unsafeSets.add(this.getBlocks(chart));
          } else {
            unsafeSets.add([]);
          }
        })
        return [...unsafeSets];
      },
      getSafeItems(chart) {
        const safeSets = new Set(this.safeItems);
        this.getBlocks(chart).forEach((block) => {
          safeSets.add(block);
        });
        return [...safeSets].sort((a, b) => a - b);
      },
      // 拓展layout尺寸
      setLayoutSize(chart) {
        const {startRow, startCol, height, width} = chart;
        if (startRow + height - 1 > this.row) {
          this.row = startRow + height - 1;
          this.setLayoutSize(chart);
        }
        if (startCol + width - 1 > this.col) {
          this.col = startCol + width - 1;
          this.setLayoutSize(chart);
        }
      },
      // 缩小layout尺寸
      resetLayoutSize() {
        const lastRowStartIndex = this.safeItems.indexOf(this.col * (this.row - 1) + 1);
        const layoutEnd = this.col * this.row;
        if (lastRowStartIndex > -1 && this.safeItems[lastRowStartIndex + this.col - 1] === layoutEnd && this.row > this.minRow) {
          this.row -= 1;
          this.resetLayoutSize();
        }
        for (let i = 1; i <= this.row; i++) {
          const lastCol = this.col * i;
          if (!this.safeItems.includes(lastCol)) {
            return;
          } else if (i === this.row && this.col > this.minCol) {
            this.col -= 1;
            this.resetLayoutSize();
          }
        }
      },
      getSafeMinRow(chart, oldChart = {}) {
        const newChart = {
          startCol: chart.startCol,
          startRow: chart.startRow,
          height: chart.height,
          width: chart.width,
        };
        for (let i = 0; i < chart.startRow; i++) {
          newChart.startRow -= 1;
          // 不能超出画布
          if (newChart.startRow === 0 || !this.checkBlocksIsSafe(newChart, oldChart, true)) {
            newChart.startRow += 1;
            return newChart;
          }
        }
        return chart;
      },
      resetCharts() {
        this.charts.sort((c1, c2) => c1.startRow - c2.startRow || c1.startCol - c2.startCol);
        for (let i = 0; i < this.charts.length; i++) {
          this.$set(this.charts, i, this.getSafeMinRow(this.charts[i], this.charts[i]));
        }
      },
      handleDragstart(e) {
        DragstartPageX = e.pageX;
        DragstartPageY = e.pageY;
        e.dataTransfer.effectAllowed = "move";
      },
      handleDragover(e) {
        e.dataTransfer.dropEffect = "move";
      },
      handleFireFoxDragover(e) {
        DragoverPageX = e.pageX;
        DragoverPageY = e.pageY;
      },
      handleDragend(index) {
        const moveX = DragoverPageX - DragstartPageX;
        const moveY = DragoverPageY - DragstartPageY;
        const moveCol = Math.round(moveX / (this.baseLength + this.baseMargin));
        const moveRow = Math.round(moveY / (this.baseLength + this.baseMargin));
        const targetChart = this.charts[index];
        const newChart = {
          startCol: targetChart.startCol + moveCol,
          startRow: targetChart.startRow + moveRow,
          height: targetChart.height,
          width: targetChart.width,
        };
        if (this.checkBlocksIsSafe(newChart, targetChart)) {
          this.$set(this.charts, index, this.getSafeMinRow(newChart, targetChart));
          this.resetCharts();
        }
      },
      handleTemplateDragstart(e) {
        DragstartPageX = e.pageX;
        DragstartPageY = e.pageY;
        e.dataTransfer.effectAllowed = "move";
      },
      handleTemplateDragend(e, index) {
        const moveX = DragoverPageX - DragstartPageX;
        const moveY = DragoverPageY - DragstartPageY;
        const {left: bodyX, top: bodyY} = document.querySelector('.charts-body').getBoundingClientRect();
        const {left: templateX, top: templateY} = e.target.getBoundingClientRect();
        let templateCol = Math.round((templateX + moveX - bodyX) / (this.baseLength + this.baseMargin)) + 1;
        let templateRow = Math.round((templateY + moveY - bodyY) / (this.baseLength + this.baseMargin)) + 1;
        if (templateCol < 1) {
          templateCol = 1;
        }
        if (templateRow < 1) {
          templateRow = 1;
        }
        const targetTemplate = this.chartTemplates[index];
        const newChart = {
          startCol: templateCol,
          startRow: templateRow,
          height: targetTemplate.height,
          width: targetTemplate.width,
        };
        if (this.checkBlocksIsSafe(newChart)) {
          this.charts.push(this.getSafeMinRow(newChart));
          this.resetCharts();
        }
      },
    }
  })
</script>
</html>
